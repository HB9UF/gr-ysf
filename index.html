<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="style.css">
<title>gr-ysf: GNU Radio modules for decoding Yaesu System Fusion C4FM packets</title>
</head>

<body>
<div id="title"></div>
<div id="body">
<h1>Introduction</h1>
<p>Yaesu System Fusion (YSF) is a radio system designed and implemented by Yaesu.
At its core, it tries to merge traditional FM with a digital voice mode. This project's
aim is to investigate the digital aspect of YSF and to provide decoding tools.
In order to meet this goal, <a href="http://gnuradio.org/">GNU Radio</a> is
employed to do most of the tricky things outlined in the 
<a href="Yaesu_Amateur_Radio_Digital_Specs_1V01.pdf">technical specifications of the system</a>.
This work is based on revision 1.01 of the manual. Due to the proprietary nature
of those specifications, Yaesu can amend and change things as they wish. They
have done so in the past. Currently, you can probably download revision 1.02 or
newer from the <a href="http://www.yaesu.com">Yaesu page</a>, but 1.01 is not
available anymore and therefore hosted locally. People reading this should
probably be mildly concerned about the consequences of the choice made by
Yaesu.</p>

<p>Please note that this is not a software package that you can download and
simply tune into YSF signals without putting some effort. This is merely a proof of concept that demonstrates that it is
possible to build a receiver for YSF. Insights gained from this work might be
used to add YSF support to e.g. <a href="http://wiki.radioreference.com/index.php/Digital_Speech_Decoder_%28software_package%29">
DSD</a>, but this project is not a scanner application per se. Also note that
this is not a finished product. For example, the current code misses several
opportunities to apply <a href="https://en.wikipedia.org/wiki/Forward_error_correction">
forward error correction (FEC)</a>, the quality of the audio output is therefore
reduced heavily. Check the <a href="https://github.com/HB9UF/gr-ysf/issues">issues</a> page on github for an
overview of what you can expect. I gladly accept pull-requests :-). <a
href="https://github.com/szechyjs/mbelib">mbelib</a> is required to turn the
AMBE frames into something that you can hear. This might have legal
implications for you, please be aware of that.</p>

<p>Here is an early recording (<a href="first_recording.mp3">direct link</a>) of
what I got out of the system while transmitting with an <a
href="http://www.yaesu.com/indexVS.cfm?cmd=DisplayProducts&amp;ProdCatID=111&amp;encProdID=25F65DA12CA1FCB444A927CD14417BFD">FT1D</a>.
Reception was done with a <a href="http://greatscottgadgets.com/hackrf/">HackRF One</a>, 
although one of those cheap <a href="http://www.rtl-sdr.com/buy-rtl-sdr-dvb-t-dongles/">RTL SDR dongles</a> works just as well.</p>

<audio controls>
<source src="first_recording.mp3" type="audio/mpeg">
Your browser does not support the audio element. Use <a href="first_recording.mp3">this link</a> instead.
</audio>

<p>If you want to give it a try yourself, have a look at the <a href="getting_started.html">
Getting Started</a> page. Again, this is some experimental stuff that I am
sharing with other curious amateurs and not a "download, run and forget" kind of
program.</p>

<p>Before I dig into the details of this work, let me say thank you to the amazing
GNU Radio community who not only came up with a great software framework, but
also provided me with a lot of help when things were not working the way I
expected them to work. <a href="https://twitter.com/jmcorgan">Johnathan
Corgan</a> in particular shared a lot of the insights he gained while working on
C4FM for the past few years. <a href="http://246tnt.com/">Sylvain Munaut</a>
helped me a lot in figuring out how VW mode works. I learned a lot of
mathematical tricks from him and surely, I would not have been able to pull this
off without his help. Thanks to him, I learned more about Galois Fields than at
University. <a href="https://www.qrz.com/db/IZ0QWM">Raffaello Di Martino (IZ0QWM)</a>
provided me with a vast amount of sample data. 
<a href="https://www.qrz.com/db/VA7EEX">David Rickett (VA7EEX)</a> allowed me
to use his PiDV remotely to create correct AMBE frames and to validate the ones
generated by this project. Both of this has proven to be extremely helpful.</p>

<h1>Walkthrough</h1>
<p>This section briefly outlines the <code>ysf_rx.grc</code> flowgraph found in the
<a href="https://github.com/HB9UF/gr-ysf/tree/master/examples"><code>examples/</code></a> 
directory of the project. The flowgraph corresponds to commit
<code>6830db0</code>, although I will update this page as things progress. The
full flowgraph can be seen <a href="ysf_rx.png">here</a>, I will split it into
several parts to make this discussion easier to follow.</p>

<h2>Frontend</h2>
<img class="center" alt="Top part of the flowgraph" src="frontend.png">

<p>The quadrature signal is captured by hardware (osmocom Source) or replayed
through a file source and fed into a frequency xlating FIR filter, where it is
filtered, shifted to DC and down-sampled. The filtering is necessary to prevent
aliasing. The frequency shift is done because some SDRs have a considerable
spike at DC that is in the way. An easy way to get around that is to set the
hardware up such that the signal for interest is offset. For example, one can
set a center frequency of 432&nbsp;MHz and transmit at 432.5&nbsp;MHz. The
frequency has then to be translated downwards by 500&nbsp;kHz. The quadrature
signal is then demodulated before it is fed into the polyphase clock sync block.
This block applies the root-raised cosine (RRC) filter and outputs dibits at a
symbol rate of 4.8&nbsp;kHz. Note that the equation for the RRC filter is
completely wrong and doesn't even make sense, but the symbol rate and the
roll-off given are correct.</p>

<h2>Slicing, Mapping, Deframing and the FICH Packet</h2>
<img class="center" alt="Center part of the flowgraph" src="slicing_mapping_deframing_fich.png">

<p>The signal from the clock recovery block is sliced into the four levels that
are inherent to C4FM. They are then remapped to the dibits defined in Table 3-1
of the Yaesu spec. The YSF Deframer is my first custom block. It waits for the
sync word <code>0xd471c9634d</code> which marks the beginning of every packet.
The subsequent 200 bits are sent to the top output stream. Those are the FICH
header which contains information on the payload-content and -structure. The
subsequent 720 payload-bits are then temporarily stored inside the deframer.</p>

<p>The FICH header is decoded according to Figure 4-26 of the Yaesu spec. The
sequence of blocks needed for this is very similar to the payload decoding
outlined in the next section. Note however that in the flowchart shown above,
Golay decoding is not performed. Instead, the first 12 bits are kept and the
remainder is thrown away. I can get away with this because the first block of
the Golay-matrix is identity, but eventually I will have to do this properly.
After decoding, the FICH header hits the YSF FICH Sink, the second custom block.
This block parses the FICH header and sends back a message to the deframer,
telling it what is contained in the payload. The deframer pulls apart the payload
according to those instructions and distributes it into the three payload
streams.</p>

<h2>Data Decoding</h2>
<img class="center" alt="Data part of the flowgraph" src="data_decoding.png">
<p>This part of the flowgraph takes care of turning the dibits into the packets
expected by the data sink. This is used to display call signs, messages and
other information. Depending on type and mode, this kind of data can be
transferred in different ways. The top path implements the decoding shown in
Figure 4-30 of the specification, the bottom path implements the decoding
shown in Figure 4-31 of the spec. The two decodings only differ by their
respective parameters. In a nutshell, the dibits are de-interleaved and then,
forward error correction is applied by the Viterbi algorithm following a 
<a href="https://en.wikipedia.org/wiki/Convolutional_code">Trellis Convolitional
Code</a>. This step turns the dibits into a stream of bits where bit-errors
are hopefully corrected by the FEC. Lastly, a fixed sequence from a scrambler
is XORed with the bit-stream before the data is displayed in the DCH Sink. The
de-scrambling is done manually due to a bug in GNU Radio. It is important to
note that the scrambler is part of the system in order to have a randomly
distributed stream of data, since long sequences of the same bit would violate
some theoretical assumptions of the techniques that make this system robust
towards bit-errors. It is not there to conceal the meaning of the transmission.
</p>

<h2>Voice Decoding</h2>
<img class="center" alt="Voice part of the flowgraph, bottom" src="voice_decoding.png">

<p>Similarly, this is an implementation of Figures 4-32 and 4-23 of the Yaesu
spec, to decode DN voice and VW voice, respectively. The former is quite similar
to the approach discussed in the previous section. The custom V/D2 VCH Decoder
block undoes the weird bit triplication introduced in step 3 of the figure. 
The output of this block is an AMBE frame. Those AMBE frames enter another custom 
block, the mbelib Conversion Block. This block calls mbelib and retrieves the 
synthesized speech, which is normalized in amplitude by an AGC and sent to the speaker.</p>

<p>The bottom branch is considerably simpler: The dibits are converted into
bits by unpacking, then de-interleaved according to a pattern that was not easy
to figure out, as it is not documented by Yaesu. The standard AMBE scrambler is
then (still inside the same block) applied to the frame, which is handed to the
mbelib Conversion Block as before. IMBE is used here since the rate used in
VW mode is supposed to be backwards compatible with an IMBE rate that is luckily
supported by mbelib.</p>

<h1>License, Code and Dependencies</h1>
<p>The project is released on a <a href="https://github.com/HB9UF/gr-ysf/">github page</a> under the 
<a href="https://www.gnu.org/licenses/gpl.html">GNU GPL 3</a> license. The code
is written in C++ and was tested with g++ 4.8.4 and GNU Radio 3.7.5.
<a href="https://github.com/szechyjs/mbelib">mbelib</a> is required to
synthesize voice.</p>
</div>
</body>
</html>
